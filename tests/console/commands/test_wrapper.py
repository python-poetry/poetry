import stat
from datetime import datetime
from pathlib import Path
from unittest.mock import patch

import pytest
from cleo.application import Application
from cleo.io.buffered_io import BufferedIO

from poetry.__version__ import __version__
from src.poetry.console.commands.wrapper import WrapperCommand


@pytest.fixture
def command(tmp_path: Path):
    """Fixture providing a WrapperCommand instance with BufferedIO and temporary directory."""
    app = Application()
    cmd = WrapperCommand()
    app.add(cmd)
    cmd.set_io(BufferedIO())  # Properly configure IO using set_io
    with patch("pathlib.Path.cwd", return_value=tmp_path):
        yield cmd


@pytest.fixture
def mock_datetime():
    """Fixture to mock datetime.now for consistent date output."""
    with patch("datetime.datetime") as mock_dt:
        mock_dt.now.return_value = datetime(2025, 4, 12)
        yield mock_dt


class TestWrapperCommand:
    """Tests for the WrapperCommand class."""

    def test_is_valid_version(self):
        """Test that _is_valid_version correctly validates semantic version strings (X.Y.Z)."""
        cmd = WrapperCommand()

        # Valid versions
        assert cmd._is_valid_version("1.2.3") is True, "Version 1.2.3 should be valid"
        assert cmd._is_valid_version("0.0.1") is True, "Version 0.0.1 should be valid"
        assert cmd._is_valid_version("10.20.30") is True, "Version 10.20.30 should be valid"

        # Invalid versions
        assert cmd._is_valid_version("1.2") is False, "Version 1.2 should be invalid"
        assert cmd._is_valid_version("1.2.3.4") is False, "Version 1.2.3.4 should be invalid"
        assert cmd._is_valid_version("1.2.a") is False, "Version 1.2.a should be invalid"
        assert cmd._is_valid_version("abc") is False, "Non-numeric version should be invalid"
        assert cmd._is_valid_version("") is False, "Empty version should be invalid"

    def test_generate_script_content(self, mock_datetime):
        """Test that _generate_script_content produces the expected poetryw script content."""
        cmd = WrapperCommand()
        version = "1.2.3"
        script_content = cmd._generate_script_content(version)

        # Verify key parts of the script
        assert "#!/bin/bash" in script_content, "Script should start with shebang"
        assert f"Poetry version {version}" in script_content, "Script should include version"
        assert "Generated by `poetry wrapper` on 2025-04-12" in script_content, "Script should include date"
        assert 'POETRY_HOME="$HOME/.poetry/versions/$POETRY_VERSION"' in script_content, "Script should set POETRY_HOME"
        assert 'if ! curl -sSL https://install.python-poetry.org | POETRY_HOME="$POETRY_HOME" python3 - --version "$POETRY_VERSION"; then' in script_content, "Script should include installation command"
        assert 'if [ ! -f "$POETRY_HOME/bin/poetry" ]; then' in script_content, "Script should check for poetry executable after installation"
        assert 'echo "Error: Poetry executable not found at $POETRY_HOME/bin/poetry after installation."' in script_content, "Script should include post-installation error message"
        assert 'exec "$POETRY_HOME/bin/poetry" "$@"' in script_content, "Script should exec poetry"

    def test_get_current_date(self):
        """Test that _get_current_date returns the current date in YYYY-MM-DD format."""
        cmd = WrapperCommand()
        with patch("datetime.datetime") as mock_dt:
            mock_dt.now.return_value = datetime(2025, 4, 12)
            date = cmd._get_current_date()
        assert date == "2025-04-12", "Date should be formatted as YYYY-MM-DD"

    def test_make_executable_on_posix(self, tmp_path: Path):
        """Test that _make_executable sets correct permissions on POSIX systems."""
        cmd = WrapperCommand()
        with patch("os.name", "posix"):
            script_file = tmp_path / "poetryw"
            script_file.write_text("# script")
            cmd._make_executable(script_file)

            mode = script_file.stat().st_mode
            assert mode & stat.S_IXUSR, "Owner execute permission not set"
            assert mode & stat.S_IXGRP, "Group execute permission not set"
            assert mode & stat.S_IXOTH, "Others execute permission not set"
            assert mode & stat.S_IRUSR, "Owner read permission not set"
            assert mode & stat.S_IWUSR, "Owner write permission not set"

    def test_handle_with_default_version(self, tmp_path, mock_datetime):
        """Test handle with default Poetry version creates files and outputs success."""
        cmd = WrapperCommand()
        cmd._io = BufferedIO()

        with patch("pathlib.Path.cwd", return_value=tmp_path):
            result = cmd.handle()

        assert result == 0, "Command should succeed"
        output = cmd._io.fetch_output()
        assert "Poetry wrapper generated successfully" in output
        assert "Run ./poetryw to use Poetry with the pinned version." in output

        properties_file = tmp_path / "poetry-wrapper.properties"
        script_file = tmp_path / "poetryw"
        assert properties_file.exists(), "Properties file should be created"
        assert properties_file.read_text() == f"version={__version__}\n", "Properties file should contain version"
        assert script_file.exists(), "Script file should be created"
        assert f"Poetry version {__version__}" in script_file.read_text(), "Script should include version"

    def test_handle_with_custom_version(self, tmp_path, mock_datetime):
        """Test handle with a custom Poetry version creates files and outputs success."""
        cmd = WrapperCommand()
        cmd._io = BufferedIO()
        custom_version = "2.1.2"

        with patch("pathlib.Path.cwd", return_value=tmp_path), patch.object(cmd, "option", return_value=custom_version):
            result = cmd.handle()

        assert result == 0, "Command should succeed"
        output = cmd._io.fetch_output()
        assert "Poetry wrapper generated successfully" in output
        assert f"version {custom_version}" in output
        assert "Run ./poetryw to use Poetry with the pinned version." in output

        properties_file = tmp_path / "poetry-wrapper.properties"
        script_file = tmp_path / "poetryw"
        assert properties_file.exists(), "Properties file should be created"
        assert properties_file.read_text() == f"version={custom_version}\n", "Properties file should contain custom version"
        assert script_file.exists(), "Script file should be created"
        assert f"Poetry version {custom_version}" in script_file.read_text(), "Script should include custom version"

    def test_handle_with_invalid_version(self, tmp_path, mock_datetime):
        """Test handle with an invalid Poetry version outputs error and fails."""
        cmd = WrapperCommand()
        cmd._io = BufferedIO()
        invalid_version = "1.2"

        with patch("pathlib.Path.cwd", return_value=tmp_path):
            with patch.object(cmd, "option", return_value=invalid_version):
                result = cmd.handle()

        assert result == 1, "Command should fail with invalid version"
        error_output = cmd._io.fetch_error()
        assert f"Invalid version format: {invalid_version}" in error_output
        assert "Expected format: X.Y.Z" in error_output

        properties_file = tmp_path / "poetry-wrapper.properties"
        script_file = tmp_path / "poetryw"
        assert not properties_file.exists(), "Properties file should not be created"
        assert not script_file.exists(), "Script file should not be created"

    def test_handle_with_existing_files(self, tmp_path, mock_datetime):
        """Test handle overwrites existing files and outputs warning."""
        cmd = WrapperCommand()
        cmd._io = BufferedIO()

        # Create existing files
        properties_file = tmp_path / "poetry-wrapper.properties"
        script_file = tmp_path / "poetryw"
        properties_file.write_text("version=0.0.0\n")
        script_file.write_text("# old script")

        with patch("pathlib.Path.cwd", return_value=tmp_path):
            result = cmd.handle()

        assert result == 0, "Command should succeed"
        output = cmd._io.fetch_output()
        assert "Warning: Existing wrapper files detected. They will be overwritten." in output
        assert f"Poetry wrapper generated successfully for version {__version__}" in output

        assert properties_file.exists(), "Properties file should still exist"
        assert properties_file.read_text() == f"version={__version__}\n", "Properties file should be overwritten"
        assert script_file.exists(), "Script file should still exist"
        assert f"Poetry version {__version__}" in script_file.read_text(), "Script file should be overwritten"

    def test_handle_properties_file_write_error(self, tmp_path, mock_datetime):
        """Test handle fails gracefully when properties file write fails."""
        cmd = WrapperCommand()
        cmd._io = BufferedIO()

        with patch("pathlib.Path.cwd", return_value=tmp_path):
            with patch("pathlib.Path.write_text", side_effect=IOError("Permission denied")):
                result = cmd.handle()

        assert result == 1, "Command should fail on write error"
        error_output = cmd._io.fetch_error()
        assert "Failed to write" in error_output
        assert "poetry-wrapper.properties" in error_output

        properties_file = tmp_path / "poetry-wrapper.properties"
        script_file = tmp_path / "poetryw"
        assert not properties_file.exists(), "Properties file should not be created"
        assert not script_file.exists(), "Script file should not be created"

    @pytest.mark.parametrize("invalid_version", ["1.2.3.4", "1.2.a"])
    def test_invalid_version_edge_cases(self, tmp_path, invalid_version, mock_datetime):
        cmd = WrapperCommand()
        cmd._io = BufferedIO()
        with patch("pathlib.Path.cwd", return_value=tmp_path):
            with patch.object(cmd, "option", return_value=invalid_version):
                result = cmd.handle()
        assert result == 1, "Should fail with invalid version"
        error_output = cmd._io.fetch_error()
        assert f"Invalid version format: {invalid_version}" in error_output
        assert "Expected format: X.Y.Z" in error_output

    def test_handle_script_file_write_error(self, tmp_path, mock_datetime):
        cmd = WrapperCommand()
        cmd._io = BufferedIO()

        with patch("pathlib.Path.cwd", return_value=tmp_path):
            def write_text_side_effect(self, text, *args, **kwargs):
                if "Poetry version" in text:
                    raise IOError("Permission denied")
                return text

            with patch("pathlib.Path.write_text", new=write_text_side_effect):
                result = cmd.handle()

        assert result == 1, "Should fail on write error"
        error_output = cmd._io.fetch_error()
        assert "Failed to write or configure" in error_output
        assert "poetryw" in error_output
